# Project 05: Breathing LED

An LED that slowly fades in and out — like a sleeping MacBook. No CPU, no C, no Arduino. Just Verilog and FPGA logic gates doing all the work.

---

## Before You Read the Code — Three Ideas You Need

### 1. A clock is a heartbeat

An FPGA is static without a clock. It's just frozen gates. A clock wire pulses HIGH/LOW 48 million times per second on this board, and every register updates on each rising edge. That's what makes it "run."

### 2. A counter is a clock divider

An 8-bit counter's top bit flips every 256 cycles. A 27-bit counter's top bit flips every 134 million cycles. This is how hardware slows down time — you just look at higher bits.

### 3. PWM is fake analog

The LED is either ON or OFF. But switch it ON for 75% of a 187,500 Hz cycle and your eye sees 75% brightness. That's all PWM is.

---

## How It Works

Two counters run in parallel. That's the whole design.

**The fast counter** (`pwm_counter`, 8-bit) races from 0→255 at 187,500 times per second. Your eye can't see that flicker.

**The slow counter** (`breath_counter`, 27-bit) takes ~2.8 seconds to wrap around completely. Its upper bits form the brightness value that changes slow enough to actually see.

```
2^27 cycles ÷ 48,000,000 Hz ≈ 2.8 seconds per full cycle
```

### The triangle wave trick

We want brightness to go 0→255→0→255→... without any `if/else` state machine. The trick is exploiting the bit structure of `breath_counter`:

- **Bit 26 (MSB)** = direction flag. It's `0` for the first 1.4 seconds, `1` for the next 1.4 seconds.
- **Bits 25–18** = an 8-bit magnitude that counts 0→255 during each half.

```verilog
wire direction = breath_counter[26];
wire [7:0] magnitude = breath_counter[25:18];
assign brightness = direction ? ~magnitude : magnitude;
```

When `direction = 0`: brightness goes 0→255 (fade in).  
When `direction = 1`: `~magnitude` inverts the ramp, so 0→255 becomes 255→0 (fade out).

The clean part: at the exact moment `direction` flips from 0→1, `magnitude` is `0xFF` and `~0x00 = 0xFF` — so brightness stays at 255 with no jump. Same math works at the rollover back to 0. No glitch, no special case needed.

### The comparator

```verilog
assign led = (pwm_counter < brightness);
```

One line. This is the DAC. If the fast counter is below the brightness target, the LED is on. That ratio — ON ticks out of 256 total — is the duty cycle, which your eye reads as brightness.

---

## RTL Schematic

Generated by TerosHDL + Yosys. You can see the four hardware blocks: the oscillator, the two flip-flop chains (the counters), the mux (the `direction ? ~magnitude : magnitude` select), and the comparator driving the LED pin.

![Breathing LED RTL Schematic](breathing_schematic.svg)

---

## Formal Verification

The `.sby` file runs a mathematical proof — not a simulation, an actual proof that certain properties hold for all possible states. The tool is SymbiYosys with the Yices SMT solver.

The proof strategy is **k-induction**: show the properties hold from the initial state (base case), then show that if they hold for any 50 consecutive steps they must hold for step 51 (inductive step). Together those two things mean the properties hold forever.

**What we proved:**

During fade-in, brightness never decreases. During fade-out, it never increases. At the fade-in→fade-out transition, brightness is 255 on both sides of the boundary. At the rollover, it's 0 on both sides. And the LED is never on when brightness is zero.

One assertion we got wrong initially: `brightness == 0xFF → led must be 1`. Looked reasonable. Base case passed. Induction failed immediately — the solver found the one tick per 256 where `pwm_counter == 0xFF` and `255 < 255` is false. The correct assertion is:

```verilog
assert((brightness == 8'hFF && pwm_counter != 8'hFF) ? led : 1'b1);
```

Max brightness is 255/256 duty cycle, not 100%. The hardware was right; the assertion was wrong.

**The pattern to remember:** base case passes + induction fails = your assertion is accidentally relying on the initial state, not actually universally true.

Run it:

```bash
sby -f breathing.sby
```

Expected:

```
DONE (PASS, rc=0)
```

---

## Build and Flash

```bash
apio build && apio upload
```

If your PATH isn't set:

```bash
export PATH=$HOME/.apio/packages/oss-cad-suite/bin:$PATH
```

---

## File Structure

```
05-breathing-led/
├── breathing.v          # Design + formal verification properties
├── breathing.sby        # SymbiYosys proof configuration
├── breathing.pcf        # Pin constraints (which physical pin = LED)
├── apio.ini             # Apio project config (board, toolchain)
├── breathing_schematic  # RTL schematic (SVG, generated by TerosHDL)
├── breathing/           # sby output directory (proof artifacts, traces)
└── _build/              # apio build output (bitstream, reports)
```

---

## Toolchain notes

This uses a fully open-source stack: Yosys for synthesis, nextpnr for place-and-route, icepack for bitstream generation — all managed by Apio.

**TerosHDL schematic viewer:** Getting this working with Apio's toolchain on Ubuntu required a small trampoline script at `/usr/local/bin/yowasp-yosys` that redirects the extension's calls to the Apio Yosys binary.

**`(* keep = 1 *)` attributes:** Normally Yosys optimizes away intermediate signals. This attribute tells it to keep them visible in the schematic — useful for seeing `direction`, `magnitude`, and `brightness` as separate named nodes rather than having them folded into surrounding logic.

---

## Glossary

| Term | What it means here |
|---|---|
| `reg` | A flip-flop. Stores bits, updates on clock edges. |
| `wire` | Combinational signal. Updates instantly when inputs change. |
| PWM | Pulse Width Modulation — fake analog via fast switching. |
| Duty cycle | Fraction of time a PWM signal is HIGH. 75% duty ≈ 75% brightness. |
| `$past(x)` | In formal proofs: value of signal `x` one clock cycle ago. |
| `assume()` | Constrain the solver's inputs to a condition. |
| `assert()` | Ask the solver to prove this is always true. |
| k-induction | Base case + inductive step → proven true for all time. |
| `SB_HFOSC` | iCE40 built-in 48 MHz oscillator primitive. |
| `~x` | Bitwise NOT. `~0x00 = 0xFF`. `~0xFF = 0x00`. |